
#include "interrupt_routines.h"

/* 12 bits resolution: output goes from -2048 to 2047 */
#define MAX_ACC_OUT 2047

/* sensitivity of the conversion from digit to mg provided by the datasheet: 2 mg/digit */
#define SENSITIVITY 2

/* 1g= 9.81 m/s^2 */
#define g 9.81

    
/* array to save accelerometer's registers output */
uint8_t accelerometer_data[2*AXES];

/* function to scale and convert the x,y,z output values and save them in the array to send through UART */
void SaveAccelerometerData (void);

/* ISR generated by the timer each 10 ms in which the accelerometer's output registers are read */
CY_ISR(Custom_ISR) {

    ErrorCode error;
    uint8_t status_reg_value;
    
    /* clear the timer's status register */
    Timer_ReadStatusRegister();
    
    /*read the accelerometer's status register */
    error= I2C_Peripheral_ReadRegister(LIS3DH_DEVICE_ADDRESS, STATUS_REG, &status_reg_value);
    
    /* if no error occurs while reading */
    if (error == NO_ERROR)  {
        
        /* new data are available on the x,y,z registers */
        if (status_reg_value & STATUS_REG_NEW_DATA) {
            
            /* multi-read of the x,y,z 2 bytes outputs in the corresponding registers */
            error= I2C_Peripheral_ReadRegisterMulti(LIS3DH_DEVICE_ADDRESS, OUT_X_L, 2*AXES, accelerometer_data);
            
            if (error == NO_ERROR){
                
                /* convert the values into m/s^2 and save them in the array trasmitted through UART */
                SaveAccelerometerData();
                
                /* flag to inform that new data are available */
                new_data=1;
            }
        }
    }
}

/* for each axis: data from the low and high registers are saved into a 16-bits variable, then the
value is converted in a floating point acceleration value in m/s^2 and casted in a 32 bits integer.
the value is saved in 4 bytes on the array to be trasmitted to UART */

 void SaveAccelerometerData() {
    
    uint8_t i;
    int16 read_value;
    float converted_value;
    int32 casted_value;
   
    /* for x, y, z */
    for (i=0; i< AXES; i++) {
    
    /* output registers are left adjusted: put in a 16 bits variable the two 
    registers related with the axis and then shift to the right of 4 bits (12 bits resolution) */
        read_value= (int16) ((accelerometer_data[2*i]| (accelerometer_data[2*i+ 1]<<8))) >>4;
    
    /* since 12 bits resolution,constraints added: output from -2048 to 2047 */
    if (read_value > MAX_ACC_OUT)
    
        read_value = MAX_ACC_OUT;
    
    if (read_value < -MAX_ACC_OUT -1) 
    
        read_value= -MAX_ACC_OUT-1;
    
    
    /*value converted in m/s^2, conversion in mg/digit using the sensitivity of 2 mg/digit */
    converted_value = read_value* SENSITIVITY * 0.001 *g; 
    
    
    /* cast the float into a integer of 32 bits taking 4 decimals */
    casted_value= (int32) (converted_value * 10000);
    
    
    /* save the the 4 bytes in the array which will be sent though UART */
    packet_to_send[NUM_BYTES*i +1] = (uint8_t)(casted_value & 0xFF); 
    
    packet_to_send [NUM_BYTES*i+2] = (uint8_t)((casted_value>>8) & 0xFF);
    
    packet_to_send [NUM_BYTES*i+3] = (uint8_t)((casted_value >> 16) & 0xFF);
    
    packet_to_send [NUM_BYTES*i+4] = (uint8_t)(casted_value >> 24);
    }
 }
   

            


/* [] END OF FILE */
