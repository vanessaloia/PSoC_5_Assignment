
#include "interrupt_routines.h"
#include "stdio.h"

/* 10 bits resolution: output can go from -512 to 511 */
#define MAX_ACC_OUT 511

/* sensitivity of the conversione from digit to mg [mg/digit] */
#define SENSITIVITY 4
    
/* array to save accelerometer's registers output */
uint8_t accelerometer_data[NUM_BYTES*AXES];

/* function to scale the x,y,z output values and save them in the array to send through UART */
void SaveAccelerometerData (void);

/* ISR generated by the timer each 10 ms in which the accelerometer's output registers are read */
CY_ISR(Custom_ISR) {

    ErrorCode error;
    uint8_t status_reg_value;
    
    /* clear the status register of the timer */
    Timer_ReadStatusRegister();
    
    /*read the accelerometer's status register */
    error= I2C_Peripheral_ReadRegister(LIS3DH_DEVICE_ADDRESS, STATUS_REG, &status_reg_value);
    
    /* if no error occurs while reading */
    if (error == NO_ERROR)  {
        
        /* new data are available on at least one of the x,y,z registers */
        if (status_reg_value & STATUS_REG_NEW_DATA) {
            
            /* multi-read of the x,y,z 2 bytes outputs in the corresponding registers */
            error= I2C_Peripheral_ReadRegisterMulti(LIS3DH_DEVICE_ADDRESS, OUT_X_L, NUM_BYTES*AXES, accelerometer_data);
            
            if (error == NO_ERROR){
                
                /* scale the values and save it in the array sent through UART */
                SaveAccelerometerData();
                
                /* flag to inform that new data are available */
                new_data=1;
            }
        }
                   
        /* no new data are available in any register*/
            else 
                new_data=0;
        }
}

 void SaveAccelerometerData() {
    
    uint8_t i;
    int16 scaled_value;
    
    /* for x, y, z */
    for (i=0; i< AXES; i++) {
        
    /* output registers are left adjusted: put in a 16 bit variable the two 
    registers related with the axis and then shift to the right of 6 bits */
        
    scaled_value= (int16) ((accelerometer_data[NUM_BYTES*i]| (accelerometer_data[NUM_BYTES*i+ 1]<<8))) >>6;
    
    /* since 10 bits resolution,constraints added: output from -512 to 511 */
    if (scaled_value > MAX_ACC_OUT) 
        
        scaled_value= MAX_ACC_OUT;
    
    if (scaled_value < -MAX_ACC_OUT -1)
    
        scaled_value = -MAX_ACC_OUT -1; 
    
    /* conversion of the value in mg, scaling with a sensitivity of 4mg/git (provided by the datasheet */
    scaled_value = scaled_value*SENSITIVITY;
    
    /* save the the two bytes in the array which will be sent though UART */
    packet_to_send[NUM_BYTES*i +1] = (uint8_t)(scaled_value& 0xFF);
    
    packet_to_send [NUM_BYTES*i+2] = (uint8_t)(scaled_value>>8);
    }
 }
   

            


/* [] END OF FILE */
